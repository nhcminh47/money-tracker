# Low-Level Design (LLD) — Money Tracker

## Overview
This document complements the HLD with concrete implementation details: project layout, data model, synchronization algorithm, API contracts, and platform-specific considerations for Capacitor.

## Project Layout

```
money-tracker/
├─ app/                   # Next.js App Router (pages and layouts)
│  ├─ layout.tsx          # Root layout with PWA metadata
│  ├─ page.tsx            # Dashboard page
│  ├─ accounts/           # Account management pages
│  ├─ transactions/       # Transaction pages
│  ├─ settings/           # Settings pages
│  └─ api/                # API routes (optional, for server-side features)
├─ components/            # React components
│  ├─ ui/                 # Reusable UI components
│  └─ features/           # Feature-specific components
├─ lib/                   # Utilities, models, services
│  ├─ db/                 # Dexie database schemas and models
│  ├─ services/           # Sync, auth, backup services
│  ├─ hooks/              # React hooks
│  └─ utils/              # Helper functions
├─ public/                # Static assets
│  ├─ manifest.json       # PWA manifest (icons, theme, display mode)
│  ├─ icons/              # App icons (multiple sizes for PWA)
│  ├─ sw.js               # Service Worker (or generated by next-pwa)
│  └─ offline.html        # Offline fallback page
├─ out/                   # Build output (Next.js static export)
├─ docs/
│  ├─ HLD.md
│  ├─ LLD.md
│  └─ BACKLOG.md
├─ scripts/               # Build and deploy scripts
├─ next.config.js         # Next.js config with static export + PWA
├─ package.json
├─ tailwind.config.ts
├─ tsconfig.json          # TypeScript config with path aliases
└─ README.md
```

Note: This is a standard Next.js PWA structure. Service Worker can be generated using `next-pwa` plugin or custom implementation.

## Tech Stack
- Frontend: Next.js 14+ (App Router) + TypeScript + React 18
- Build tool: Turbopack (dev) / Webpack (production)
- Styling: TailwindCSS + CSS Modules
- Local DB: IndexedDB via Dexie
- PWA: next-pwa plugin (Service Worker generation) or Workbox
- Offline: Service Worker + Cache API + Background Sync API
- Backend (optional): Supabase (Postgres + Auth + Storage) or Firebase
- Deployment: Vercel/Netlify/Cloudflare Pages (static hosting with CDN)
- CI/CD: GitHub Actions (build, test, deploy)
- Build mode: Static export (`output: 'export'`) for full offline capability
- Security: Web Crypto API (encryption), DOMPurify (XSS protection)
- Testing: Jest (unit), Playwright (E2E), React Testing Library
- AI/ML (optional):
  - Client-side: TensorFlow.js for local categorization models
  - OCR: Tesseract.js (free, runs in browser) or Google Vision API (1000 free requests/month)
  - LLM: OpenAI API (free trial), Google Gemini API (free tier), or Anthropic Claude (free tier)
  - NLP: compromise.js for client-side natural language parsing

## Data Model
- Entities:
  - Account
    - id: string (UUID)
    - name: string
    - type: enum (Cash, Bank, Card, Wallet, Other)
    - currency: string (ISO code)
    - icon: string (emoji or icon identifier)
    - balance: number (derived)
    - createdAt, updatedAt: ISO timestamp

  - Transaction
    - id: string (UUID)
    - accountId: string
    - amount: number
    - currency: string
    - categoryId: string | null
    - type: enum (Expense, Income, Transfer)
    - toAccountId: string | null (for Transfer type)
    - notes: string
    - date: ISO date
    - cleared: boolean
    - createdAt, updatedAt
    - deleted: boolean (soft delete for sync tombstones)
    - meta: { deviceId, syncVersion }

  - Category
    - id, name, parentId?, color, type (expense/income)

  - ChangeLogEntry
    - id: string
    - entity: string
    - entityId: string
    - op: enum (create, update, delete)
    - payload: JSON
    - timestamp
    - deviceId

Indexes: index by accountId, date, categoryId, and a composite index for change-log (deviceId + timestamp).

## Sync Algorithm
- Client maintains a local change-log for all modifications.
- On sync, client sends batched change-log entries since last sync token to server.
- Server applies changes in order, resolves conflicts using "last-writer-wins" (LWW) on timestamp or a merge strategy for non-overlapping fields.
- Deleted records: keep tombstones (`deleted: true`) in changelog for sync window (e.g., 30 days) to propagate deletes to other devices.
- Server responds with authoritative snapshot or diff; client applies patches and clears synced change-log entries.
- Sync tokens: use incremental integer or UUID-based checkpointing with server-side versioning. Tokens expire after 30 days; client must request full sync if token expired.
- Full sync flag: client can request `fullSync: true` on first sync or corruption recovery to get complete dataset.

## API Contracts (REST)
- POST /sync
  - Request: { deviceId, lastSyncToken, changes: [ChangeLogEntry], fullSync?: boolean }
  - Response (success): { newSyncToken, patches: [ { entity, entityId, payload, op } ], serverTime }
  - Response (error): { error: string, code: string } (codes: TOKEN_EXPIRED, CONFLICT, RATE_LIMIT)
  - Rate limit: 60 requests/minute per device

- POST /backup
  - Request: encrypted backup blob (multipart/form-data or base64 JSON)
  - Response (success): { backupId, uploadedAt }
  - Response (error): { error: string }

- Auth: Bearer tokens (JWT) from Supabase/Firebase in Authorization header

## Local Persistence (Dexie) Example
- Tables: accounts, transactions, categories, changelog, meta
- Use Dexie hooks to patch createdAt/updatedAt and push ChangeLogEntry on write operations.

## PWA Implementation

### Web App Manifest (`public/manifest.json`)
```json
{
  "name": "Money Tracker",
  "short_name": "Money",
  "description": "Personal finance tracker - offline-first PWA",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#4f46e5",
  "orientation": "portrait-primary",
  "icons": [
    { "src": "/icons/icon-72x72.png", "sizes": "72x72", "type": "image/png" },
    { "src": "/icons/icon-96x96.png", "sizes": "96x96", "type": "image/png" },
    { "src": "/icons/icon-128x128.png", "sizes": "128x128", "type": "image/png" },
    { "src": "/icons/icon-144x144.png", "sizes": "144x144", "type": "image/png" },
    { "src": "/icons/icon-152x152.png", "sizes": "152x152", "type": "image/png" },
    { "src": "/icons/icon-192x192.png", "sizes": "192x192", "type": "image/png" },
    { "src": "/icons/icon-384x384.png", "sizes": "384x384", "type": "image/png" },
    { "src": "/icons/icon-512x512.png", "sizes": "512x512", "type": "image/png" }
  ],
  "categories": ["finance", "productivity"],
  "screenshots": [
    { "src": "/screenshots/dashboard.png", "sizes": "540x720", "type": "image/png" }
  ]
}
```

### Service Worker Strategy
- **Cache Strategy**: Network-first for API calls, Cache-first for static assets
- **Runtime Caching**: Cache transactions, accounts, categories in Cache API alongside IndexedDB
- **Background Sync**: Queue sync requests when offline, retry when connection restored
- **Update Flow**:
  1. Service Worker checks for updates on page load
  2. New SW installed in background, waits for activation
  3. Show update notification: "New version available"
  4. User clicks "Update" → call `skipWaiting()` and reload
- **Offline Fallback**: Serve `/offline.html` when network unavailable and page not cached

### next-pwa Configuration (`next.config.js`)
```javascript
const withPWA = require('next-pwa')({
  dest: 'public',
  register: true,
  skipWaiting: false, // Wait for user confirmation before activating
  disable: process.env.NODE_ENV === 'development',
  runtimeCaching: [
    {
      urlPattern: /^https:\/\/api\.example\.com\/.*$/,
      handler: 'NetworkFirst',
      options: {
        cacheName: 'api-cache',
        expiration: { maxEntries: 100, maxAgeSeconds: 24 * 60 * 60 }
      }
    },
    {
      urlPattern: /\.(?:png|jpg|jpeg|svg|gif|webp)$/,
      handler: 'CacheFirst',
      options: {
        cacheName: 'image-cache',
        expiration: { maxEntries: 50, maxAgeSeconds: 30 * 24 * 60 * 60 }
      }
    }
  ]
});

module.exports = withPWA({
  output: 'export',
  images: { unoptimized: true },
  // ... other Next.js config
});
```

### Installation Prompt
- Detect `beforeinstallprompt` event and save reference
- Show custom "Install App" button in UI
- On click, call `prompt.prompt()` and track user choice
- Hide button after installation or if user dismisses

### Push Notifications (Optional)
- Use Web Push API for transaction reminders and sync alerts
- Require user permission: `Notification.requestPermission()`
- Store push subscription in backend for sending notifications
- Display notifications using Service Worker's `showNotification()`

## Backup & Restore
- Backup: create JSON export of all tables, encrypt with AES-GCM using user passphrase, upload to chosen storage via OAuth.
- Restore: download, decrypt with passphrase, validate schema version, apply entries into local DB (inserting changelog entries to sync later).

## Testing & CI
- Unit tests: Jest for utility functions and Dexie interactions (use mock IndexedDB environment).
- E2E: Playwright to test critical flows in the web app.
- CI: GitHub Actions to run lint, build, test; on push tag build artifacts and upload to Vercel/Netlify.

## Platform Considerations

### Browser Support
- **Target browsers**: Chrome 90+, Safari 14+, Firefox 88+, Edge 90+
- **PWA features by platform**:
  - **iOS Safari 16.4+**: Full PWA support including Add to Home Screen, notifications, background sync
  - **Android Chrome**: Full PWA support with install prompt, notifications, background sync
  - **Desktop (Chrome/Edge)**: Install to OS, runs as standalone app window
  - **iOS Safari <16.4**: Limited PWA support (no push notifications, limited background sync)
- **Graceful degradation**: App works in all modern browsers, PWA features enhance experience when available
- **Feature detection**: Check for Service Worker, Push API, Background Sync API support before using

### iOS Specific Considerations
- Add meta tags for iOS home screen:
  ```html
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Money Tracker">
  <link rel="apple-touch-icon" href="/icons/apple-touch-icon.png">
  ```
- iOS Safari clears Service Worker cache after 7 days of non-use (IndexedDB persists)
- Request persistent storage: `navigator.storage.persist()` to prevent eviction
- Test on real iOS devices (Safari behavior differs from desktop)

### Android Specific Considerations
- Chrome shows install banner automatically after engagement heuristics met
- Support WebAPK for native-like installation experience
- Test on various Android versions (8.0+) and browsers (Chrome, Samsung Internet)

### Desktop Considerations
- PWA installs as desktop app on Windows/Mac/Linux via Chrome/Edge
- Appears in Start Menu, Applications folder, taskbar
- Keyboard shortcuts and accessibility important for desktop users

### Performance Targets
- Lighthouse PWA score: 90+
- First Contentful Paint: <1.5s
- Time to Interactive: <3.5s on 3G
- Offline functionality: All features work without network

## AI Features Implementation (Optional)

### 1. Smart Transaction Categorization
- Approach A (Client-side): Train lightweight TensorFlow.js model on user's transaction history (merchant names → categories).
- Approach B (Cloud): Send transaction description to categorization API (custom or LLM-based).
- Storage: Cache predictions in IndexedDB to reduce API calls.
- UX: Show suggested category with confidence score; user can accept/reject to improve model.

### 2. Receipt OCR
- Use Capacitor Camera plugin to capture receipt photo.
- Process with Tesseract.js (client-side, free, works offline) or Google Vision API (1000 free/month).
- Extract: merchant name, date, amount, line items.
- Pre-fill transaction form; user reviews and confirms.
- Store receipt image reference (optional: compress and store in IndexedDB or upload to cloud storage).

### 3. Natural Language Input
- Parse user input like "Coffee $4.50 at Starbucks" using compromise.js or regex patterns.
- Extract: amount, merchant, implicit category.
- Alternative: Use LLM API (OpenAI/Gemini) to parse complex inputs into structured JSON.
- Rate limit: cache common patterns locally to minimize API usage.

### 4. Spending Insights & Reports
- Generate monthly summaries: "You spent 30% more on dining this month."
- Use local analysis for basic stats; optionally send aggregated data to LLM for natural language insights.
- Privacy: keep raw transactions local; only send category totals and trends to cloud APIs.

### 5. Budget Recommendations
- Analyze 3-6 months of spending history.
- Use simple heuristics (median + standard deviation) or train regression model.
- Suggest category budgets; user can tweak and save.

### Free-Tier AI Options
- Google Gemini API: Free tier with rate limits (good for insights/NLP)
- OpenAI API: Free trial credits, then pay-as-you-go (cheap for personal use)
- Tesseract.js: Fully free, runs in browser (slower but offline-capable)
- TensorFlow.js: Free, client-side training and inference
- Hugging Face Inference API: Free tier for small models

### Privacy & Security
- Default to client-side processing where possible (TensorFlow.js, Tesseract.js, compromise.js).
- For cloud APIs: anonymize data, send only necessary fields, allow user opt-out.
- Store API keys in secure storage, never in code or localStorage.

## Implementation Roadmap

### Phase 1: Core PWA (Weeks 1-4)
1. **Week 1**: Scaffold Next.js app with static export, Dexie schema, basic CRUD
   - Initialize Next.js with TypeScript, TailwindCSS, ESLint, Prettier
   - Set up Dexie database with accounts, transactions, categories tables
   - Implement basic CRUD operations for transactions
   - Add path aliases and project structure

2. **Week 2**: UI pages and PWA foundation
   - Build Dashboard, Accounts, Transactions pages with App Router
   - Create Web App Manifest and generate app icons
   - Set up next-pwa plugin and basic Service Worker
   - Add responsive mobile-first layouts with TailwindCSS

3. **Week 3**: Offline capabilities and sync
   - Implement Service Worker caching strategies
   - Add Background Sync API for queued sync requests
   - Build sync backend API (Supabase/Firebase) or mock API
   - Implement change-log based sync algorithm

4. **Week 4**: Testing and deployment
   - Add Jest unit tests for models and utilities
   - Add Playwright E2E tests for critical flows
   - Set up GitHub Actions CI/CD pipeline
   - Deploy to Vercel/Netlify with HTTPS
   - Test PWA installation on iOS, Android, Desktop

### Phase 2: Enhanced Features (Weeks 5-6)
5. **Week 5**: Auth, backup/restore, and security
   - Integrate Supabase Auth or Firebase Auth
   - Implement encrypted backup/restore with Web Crypto API
   - Add input sanitization with DOMPurify
   - Configure CSP headers and security best practices

6. **Week 6**: UX polish and analytics
   - Build reports and charts (spending by category, trends)
   - Add settings page (theme, currency, notifications)
   - Implement install prompt and update notifications
   - Add opt-in analytics (Plausible/Google Analytics)

### Phase 3: AI Features (Optional, Weeks 7+)
7. **Ongoing**: Integrate AI features incrementally
   - Smart categorization (TensorFlow.js or API)
   - Receipt OCR (Tesseract.js or Google Vision API)
   - Spending insights (local analytics or LLM API)
   - Budget recommendations
   - Natural language transaction input

### Future: Native Apps (Phase 4+)
- Evaluate user demand for native features (biometrics, advanced camera)
- If needed, wrap PWA in Capacitor or build React Native version
- Reuse data layer and sync logic, build native UI components
